defmodule {{MODULE}}Web.SubscriptionLive.Index do
  use {{MODULE}}Web, :live_view
  alias {{MODULE}}.Payments
  alias SquareClient.Plans.Formatter, as: PlanFormatter
  require Logger

  @impl true
  def mount(_params, _session, socket) do
    user = socket.assigns.current_scope.user

    current_plan = get_user_plan(user)

    # Get plans from JSON configuration using the library
    subscription_plans = PlanFormatter.get_subscription_plans(:{{APP}}, "square_plans.json")
    one_time_purchases = PlanFormatter.get_one_time_purchases(:{{APP}})

    # Mark recommended plans and filter out free plan
    plans =
      subscription_plans
      # Remove free plan from display
      |> Enum.reject(&(&1.id == :free))
      |> PlanFormatter.mark_recommended_plans(current_plan)

    one_time_plans = PlanFormatter.mark_recommended_plans(one_time_purchases, current_plan)

    # Get subscription with sync if data is missing/stale
    subscription = Payments.get_active_subscription(user, sync: true)

    socket =
      socket
      |> assign(:page_title, "Subscription Plans")
      |> assign(:plans, plans)
      |> assign(:one_time_plans, one_time_plans)
      |> assign(:current_plan, current_plan)
      |> assign(:current_user, user)
      |> assign(:subscription, subscription)
      |> assign(:processing, false)
      |> assign(:payment_error, false)
      |> assign(:payment_error_message, nil)
      |> assign(:selected_plan, nil)
      |> assign(:show_payment_modal, false)
      |> assign(:load_square_sdk, true)
      |> assign(:square_app_id, System.get_env("SQUARE_APPLICATION_ID", "sandbox-sq0idb-TEST"))
      |> assign(:square_location_id, System.get_env("SQUARE_LOCATION_ID", "TEST"))

    # Also trigger an async refresh in the background
    # Can be disabled via config :{{APP}}, :subscription_refresh_enabled, false
    if subscription && connected?(socket) &&
         Application.get_env(:{{APP}}, :subscription_refresh_enabled, true) do
      send(self(), :refresh_subscription_data)
    end

    {:ok, socket}
  end

  @impl true
  def handle_event("select_plan", %{"plan_id" => plan_id}, socket) do
    # Convert string plan_id to atom
    plan_atom = String.to_atom(plan_id)

    # Find plan in subscription plans or one-time purchases
    all_plans = socket.assigns.plans ++ socket.assigns.one_time_plans
    plan = Enum.find(all_plans, &(&1.id == plan_atom))

    if plan do
      handle_plan_selection(socket, plan)
    else
      {:noreply, socket}
    end
  end

  def handle_event("process_subscription", %{"card_id" => card_id, "plan_id" => plan_id}, socket) do
    user = socket.assigns.current_scope.user

    # Find the plan from all available plans
    # Convert plan_id string to atom for comparison
    plan_id_atom = String.to_atom(plan_id)
    all_plans = socket.assigns.plans ++ socket.assigns.one_time_plans
    plan = Enum.find(all_plans, &(&1.id == plan_id_atom))

    # Debug logging
    Logger.info("Processing subscription for plan: #{inspect(plan)}")
    Logger.info("User: #{inspect(user.id)}")

    socket = assign(socket, :processing, true)

    try do
      result =
        if plan.type == :one_time do
          # Process one-time purchase
          Payments.purchase_one_time_access(user, plan.duration_days, plan.price_cents, card_id)
        else
          # Process subscription
          Payments.create_subscription(user, plan.id, card_id)
        end

      handle_payment_result(result, socket, plan)
    rescue
      e ->
        Logger.error("Exception in process_subscription: #{inspect(e)}")

        socket =
          socket
          |> put_flash(:error, "An unexpected error occurred. Please try again.")
          |> assign(:processing, false)

        {:noreply, socket}
    end
  end

  def handle_event("cancel_subscription", _params, socket) do
    user = socket.assigns.current_scope.user

    case Payments.cancel_subscription(user) do
      {:ok, _subscription} ->
        # Update plans with new recommended status
        updated_plans =
          PlanFormatter.mark_recommended_plans(socket.assigns.plans, :free)

        socket =
          socket
          |> put_flash(:info, "Subscription cancelled successfully.")
          |> assign(:current_plan, :free)
          |> assign(:plans, updated_plans)
          |> assign(:subscription, nil)

        {:noreply, socket}

      {:error, :cancellation_failed} ->
        socket =
          socket
          |> put_flash(
            :error,
            "Unable to cancel subscription. Please try again or contact support."
          )

        {:noreply, socket}

      {:error, :no_subscription} ->
        socket =
          socket
          |> put_flash(:info, "You don't have an active subscription to cancel.")
          |> assign(:current_plan, :free)

        {:noreply, socket}

      {:error, reason} ->
        Logger.error("Failed to cancel subscription: #{inspect(reason)}")

        socket =
          socket
          |> put_flash(
            :error,
            "Failed to cancel subscription. Please try again or contact support."
          )

        {:noreply, socket}
    end
  end

  def handle_event("close_modal", _params, socket) do
    socket =
      socket
      |> assign(:show_payment_modal, false)
      |> assign(:selected_plan, nil)
      |> assign(:processing, false)
      |> assign(:payment_error, false)
      |> assign(:payment_error_message, nil)

    {:noreply, socket}
  end

  def handle_event("retry_payment", _params, socket) do
    # Simply clear the error state to show the fresh payment form again
    socket =
      socket
      |> assign(:payment_error, false)
      |> assign(:payment_error_message, nil)

    {:noreply, socket}
  end

  def handle_event("card_error", %{"error" => error}, socket) do
    # Handle card tokenization errors from Square SDK
    error_msg = "Unable to save payment method. #{error}"

    socket =
      socket
      |> assign(:processing, false)
      |> assign(:payment_error, true)
      |> assign(:payment_error_message, error_msg)

    {:noreply, socket}
  end

  @impl true
  def handle_info(:refresh_subscription_data, socket) do
    user = socket.assigns.current_scope.user

    user
    |> Payments.get_active_subscription(sync: true)
    |> update_socket_subscription(socket)
  end

  defp update_socket_subscription(nil, socket), do: {:noreply, socket}

  defp update_socket_subscription(subscription, %{assigns: %{subscription: current}} = socket)
       when subscription != current do
    {:noreply, assign(socket, :subscription, subscription)}
  end

  defp update_socket_subscription(_subscription, socket), do: {:noreply, socket}

  # Handle free plan selection - just downgrade without payment
  defp handle_plan_selection(socket, %{id: :free} = _plan) do
    socket = handle_free_plan_selection(socket)
    {:noreply, socket}
  end

  # Handle paid plan selection - show payment modal
  defp handle_plan_selection(socket, plan) do
    socket =
      socket
      |> assign(:selected_plan, plan)
      |> assign(:show_payment_modal, true)
      |> assign(:payment_error, false)
      |> assign(:payment_error_message, nil)

    {:noreply, socket}
  end

  # Handle successful subscription with refund info
  defp handle_payment_result({:ok, _subscription, refund_info}, socket, _plan) do
    success_message = build_refund_success_message(refund_info)

    socket =
      socket
      |> put_flash(:info, success_message)
      |> push_navigate(to: ~p"/subscription", replace: true)

    {:noreply, socket}
  end

  # Handle successful subscription without refund info
  defp handle_payment_result({:ok, _result_data}, socket, plan) do
    success_message = build_success_message(plan.type)

    socket =
      socket
      |> put_flash(:info, success_message)
      |> push_navigate(to: ~p"/subscription", replace: true)

    {:noreply, socket}
  end

  # Handle card declined error
  defp handle_payment_result({:error, {:card_declined, message}}, socket, _plan) do
    {:noreply, handle_inline_error(socket, "Card declined: #{message}")}
  end

  # Handle API unavailable errors
  defp handle_payment_result({:error, :api_unavailable}, socket, _plan) do
    Logger.error("Square API unavailable")
    {:noreply, handle_flash_error(socket, "Payment service is temporarily unavailable. Please try again in a few moments.")}
  end

  # Handle subscription failed
  defp handle_payment_result({:error, :subscription_failed}, socket, _plan) do
    Logger.error("Subscription creation failed")
    {:noreply, handle_inline_error(socket, "Unable to create subscription. Please verify your payment details and try again.")}
  end

  # Handle card save failed with API unavailable
  defp handle_payment_result({:error, {:card_save_failed, :api_unavailable}}, socket, _plan) do
    {:noreply, handle_flash_error(socket, "Payment service is temporarily unavailable. Please try again in a few moments.")}
  end

  # Handle card save failed with other reasons
  defp handle_payment_result({:error, {:card_save_failed, _reason}}, socket, _plan) do
    {:noreply, handle_inline_error(socket, "Unable to save payment method. Please try a different card.")}
  end

  # Handle configuration errors
  defp handle_payment_result({:error, {:configuration_error, message}}, socket, _plan) do
    {:noreply, handle_inline_error(socket, "Configuration error: #{message}. Please contact support.")}
  end

  # Handle string error messages
  defp handle_payment_result({:error, message}, socket, _plan) when is_binary(message) do
    Logger.error("Subscription failed with message: #{message}")
    {:noreply, handle_inline_error(socket, message)}
  end

  # Handle any other errors
  defp handle_payment_result({:error, reason}, socket, _plan) do
    Logger.error("Subscription failed: #{inspect(reason)}")
    {:noreply, handle_inline_error(socket, "Payment processing failed. Please try again or contact support if the issue persists.")}
  end

  # Build success message with refund info
  defp build_refund_success_message(%{refund_message: refund_msg, refund_status: "processed"}) do
    "Subscription upgraded successfully! #{refund_msg} Your refund has been automatically processed."
  end

  defp build_refund_success_message(%{refund_message: refund_msg}) do
    "Subscription upgraded successfully! #{refund_msg}"
  end

  defp build_refund_success_message(_), do: "Subscription activated successfully!"

  # Build success message based on plan type
  defp build_success_message(:one_time), do: "7-Day Pass activated successfully!"
  defp build_success_message(_), do: "Subscription activated successfully!"

  # Handle inline errors (shown in modal)
  defp handle_inline_error(socket, message) do
    socket
    |> assign(:processing, false)
    |> assign(:payment_error, true)
    |> assign(:payment_error_message, message)
  end

  # Handle flash errors (close modal, show in flash)
  defp handle_flash_error(socket, message) do
    socket
    |> put_flash(:error, message)
    |> assign(:processing, false)
    |> assign(:show_payment_modal, false)
    |> assign(:payment_error, false)
  end

  defp get_user_plan(user) do
    # Reload user to get fresh data
    user = {{MODULE}}.Repo.get!({{MODULE}}.Accounts.User, user.id)
    subscription = Payments.get_active_subscription(user)

    cond do
      # Check for active subscription first
      subscription && subscription.status == "ACTIVE" ->
        # Handle one-time pass subscriptions
        if subscription.plan_id == "premium_week_pass" do
          :week_pass
        else
          # Convert string plan_id to atom if needed
          String.to_atom(subscription.plan_id)
        end

      # Default to free plan
      true ->
        :free
    end
  end

  # Get appropriate button text based on plan and current subscription
  # Free to free
  defp get_button_text(%{id: :free}, :free) do
    "Stay on Free"
  end

  # Paid to free
  defp get_button_text(%{id: :free}, _current_plan) do
    "Downgrade to Free"
  end

  # Free to paid
  defp get_button_text(%{price_cents: price}, :free) when price > 0 do
    "Upgrade Now"
  end

  # Monthly to yearly
  defp get_button_text(%{id: :premium_yearly}, :premium_monthly) do
    "Upgrade to Yearly"
  end

  # Yearly to monthly (shouldn't happen, but just in case)
  defp get_button_text(%{id: :premium_monthly}, :premium_yearly) do
    "Downgrade"
  end

  # Weekly to monthly
  defp get_button_text(%{id: :premium_monthly}, :premium_weekly) do
    "Upgrade to Monthly"
  end

  # Default for other paid plans
  defp get_button_text(_plan, _current_plan), do: "Select Plan"

  # Already on free plan
  defp handle_free_plan_selection(%{assigns: %{current_plan: :free}} = socket) do
    socket
    |> put_flash(:info, "You're already on the free plan.")
  end

  # Downgrading from paid plan to free
  defp handle_free_plan_selection(socket) do
    user = socket.assigns.current_scope.user

    case Payments.cancel_subscription(user) do
      {:ok, _} ->
        socket
        |> put_flash(:info, "Successfully downgraded to the free plan.")
        |> assign(:current_plan, :free)
        |> push_navigate(to: ~p"/subscription")

      {:error, _} ->
        socket
        |> put_flash(:error, "Failed to downgrade. Please try again.")
    end
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
      <{{MODULE}}Web.Layouts.flash_group flash={@flash} />

      <div class="text-center mb-12">
        <h1 class="text-4xl font-bold text-gray-900 dark:text-white mb-4">
          Choose Your Plan
        </h1>
        <p class="text-lg text-gray-600 dark:text-gray-400">
          Unlock premium features for your application
        </p>

        <.subscription_status
          :if={@subscription}
          id={"subscription-status-#{@subscription.id}"}
          subscription={@subscription}
          current_plan={@current_plan}
          user={@current_user}
        />
      </div>

    <!-- All Plans Grid -->
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 max-w-5xl mx-auto">
        <!-- One-Time Purchases first -->
        <.one_time_card :for={plan <- @one_time_plans} plan={plan} current_plan={@current_plan} subscription={@subscription} />
        <!-- Then Subscription Plans -->
        <.plan_card :for={plan <- @plans} plan={plan} current_plan={@current_plan} />
      </div>

      <.payment_modal
        :if={@show_payment_modal}
        plan={@selected_plan}
        processing={@processing}
        payment_error={@payment_error}
        payment_error_message={@payment_error_message}
        square_app_id={@square_app_id}
        square_location_id={@square_location_id}
      />
    </div>
    """
  end

  defp one_time_card(assigns) do
    # Check if this one-time purchase is currently active
    # (subscription with matching plan_id and no square_subscription_id)
    assigns =
      if assigns.subscription && assigns.subscription.plan_id == "premium_week_pass" &&
           assigns.current_plan == assigns.plan.id do
        Map.put(assigns, :expires_at, assigns.subscription.next_billing_at)
      else
        Map.put(assigns, :expires_at, nil)
      end

    ~H"""
    <div class={[
      "rounded-lg border-2 p-6 relative transition-colors flex flex-col h-full",
      @current_plan == @plan.id && "border-green-500 dark:border-green-400 bg-green-50 dark:bg-green-900/10",
      @current_plan != @plan.id && "border-gray-400 dark:border-gray-600 hover:border-blue-400"
    ]}>
      <div :if={@current_plan == @plan.id} class="absolute -top-3 left-1/2 transform -translate-x-1/2">
        <span class="bg-green-500 text-white px-3 py-1 rounded-full text-xs font-semibold">
          ACTIVE
        </span>
      </div>

      <div class="flex-grow">
        <h3 class="text-xl font-bold mb-2 dark:text-white">{@plan.name}</h3>
        <p class="text-sm text-gray-600 dark:text-gray-400 mb-3">{@plan.description}</p>

        <div class="mb-4">
          <span class="text-3xl font-bold text-gray-900 dark:text-white">
            {@plan.price}
          </span>
          <span class="text-gray-600 dark:text-gray-400 text-sm ml-2">
            one-time
          </span>
        </div>

        <!-- Show expiration date if active -->
        <div :if={@expires_at} class="mb-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
          <p class="text-sm text-blue-800 dark:text-blue-200 font-medium">
            <span class="font-semibold">Expires:</span>
            <span class="ml-1">{format_date(@expires_at)}</span>
          </p>
        </div>

        <div class="mb-4 p-3 bg-green-50 dark:bg-green-900/20 rounded-lg">
          <p class="text-sm text-green-800 dark:text-green-200 font-medium flex items-center">
            <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path
                fill-rule="evenodd"
                d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                clip-rule="evenodd"
              />
            </svg>
            No auto-renewal â€¢ One-time payment
          </p>
        </div>

        <ul class="space-y-2 mb-6 text-sm">
          <li :for={feature <- @plan.features} class="flex items-start">
            <svg
              class="w-4 h-4 text-green-500 mt-0.5 mr-2 flex-shrink-0"
              fill="currentColor"
              viewBox="0 0 20 20"
            >
              <path
                fill-rule="evenodd"
                d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                clip-rule="evenodd"
              />
            </svg>
            <span class="text-gray-700 dark:text-gray-300">{feature}</span>
          </li>
        </ul>
      </div>

      <%= if @current_plan == @plan.id do %>
        <button
          disabled
          class="w-full py-2 px-4 bg-green-600 text-white rounded-lg font-semibold cursor-not-allowed mt-auto"
        >
          âœ“ Active Pass
        </button>
      <% else %>
        <%= if has_active_subscription?(@current_plan) do %>
          <button
            disabled
            class="w-full py-2 px-4 bg-gray-300 text-gray-500 rounded-lg font-semibold cursor-not-allowed mt-auto"
          >
            Already Subscribed
          </button>
        <% else %>
          <button
            phx-click="select_plan"
            phx-value-plan_id={Atom.to_string(@plan.id)}
            class="w-full py-2 px-4 bg-green-500 hover:bg-green-600 text-white rounded-lg font-semibold transition-colors mt-auto"
          >
            Get {if @plan.duration_days, do: "#{@plan.duration_days}-Day", else: ""} Pass
          </button>
        <% end %>
      <% end %>
    </div>
    """
  end

  defp plan_card(assigns) do
    ~H"""
    <div class={[
      "rounded-lg border-2 p-6 relative transition-colors flex flex-col h-full",
      @current_plan == @plan.id && "border-green-500 dark:border-green-400 bg-green-50 dark:bg-green-900/10",
      @current_plan != @plan.id && @plan[:recommended] && "border-blue-500 dark:border-blue-400 hover:border-blue-600",
      @current_plan != @plan.id && !@plan[:recommended] && "border-gray-400 dark:border-gray-600 hover:border-blue-400"
    ]}>
      <div :if={@current_plan == @plan.id} class="absolute -top-3 left-1/2 transform -translate-x-1/2">
        <span class="bg-green-500 text-white px-3 py-1 rounded-full text-xs font-semibold">
          CURRENT PLAN
        </span>
      </div>
      <div :if={@current_plan != @plan.id && @plan[:recommended]} class="absolute -top-3 left-1/2 transform -translate-x-1/2">
        <span class="bg-blue-500 text-white px-3 py-1 rounded-full text-xs font-semibold">
          RECOMMENDED
        </span>
      </div>

      <div class="flex-grow">
        <h3 class="text-xl font-bold mb-2 dark:text-white">{@plan.name}</h3>
        <p :if={Map.has_key?(@plan, :description)} class="text-sm text-gray-600 dark:text-gray-400 mb-3">{@plan.description}</p>

        <div class="mb-4">
          <span class="text-3xl font-bold text-gray-900 dark:text-white">
            {@plan.price}
          </span>
        </div>

        <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
          <p class="text-sm text-blue-800 dark:text-blue-200 font-medium flex items-center">
            <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path
                fill-rule="evenodd"
                d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z"
                clip-rule="evenodd"
              />
            </svg>
            Auto-renews â€¢ Cancel anytime
          </p>
        </div>

        <ul class="space-y-2 mb-6 text-sm">
          <li :for={feature <- @plan.features} class="flex items-start">
            <svg
              class="w-4 h-4 text-green-500 mt-0.5 mr-2 flex-shrink-0"
              fill="currentColor"
              viewBox="0 0 20 20"
            >
              <path
                fill-rule="evenodd"
                d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                clip-rule="evenodd"
              />
            </svg>
            <span class="text-gray-700 dark:text-gray-300">{feature}</span>
          </li>
        </ul>
      </div>

      <%= cond do %>
        <% @current_plan == @plan.id -> %>
          <button
            disabled
            class="w-full py-2 px-4 bg-gray-300 text-gray-500 rounded-lg font-semibold cursor-not-allowed mt-auto"
          >
            Current Plan
          </button>
        <% @current_plan == :premium_yearly && @plan.id == :premium_monthly -> %>
          <button
            disabled
            class="w-full py-2 px-4 bg-gray-300 text-gray-500 rounded-lg font-semibold cursor-not-allowed mt-auto"
          >
            Already on Yearly
          </button>
        <% true -> %>
          <button
            phx-click="select_plan"
            phx-value-plan_id={Atom.to_string(@plan.id)}
            class={[
              "w-full py-2 px-4 rounded-lg font-semibold transition-colors mt-auto",
              @plan[:recommended] && "bg-blue-500 hover:bg-blue-600 text-white",
              !@plan[:recommended] &&
                "bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-900 dark:text-white"
            ]}
          >
            {get_button_text(@plan, @current_plan)}
          </button>
      <% end %>
    </div>
    """
  end

  defp payment_modal(assigns) do
    assigns =
      assigns
      |> assign_new(:payment_error, fn -> false end)
      |> assign_new(:payment_error_message, fn -> nil end)

    ~H"""
    <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div class="bg-white dark:bg-gray-800 rounded-lg p-8 max-w-md w-full mx-4">
        <div class="flex justify-between items-center mb-6">
          <h2 class="text-2xl font-bold dark:text-white">
            {if @plan.type == :one_time,
              do: "Complete Your Purchase",
              else: "Complete Your Subscription"}
          </h2>
          <button
            phx-click="close_modal"
            class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
            disabled={@processing}
          >
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
          </button>
        </div>

        <div class="border-t border-b dark:border-gray-700 py-4 mb-6">
          <div class="flex justify-between mb-2">
            <span class="text-gray-600 dark:text-gray-400">Plan:</span>
            <span class="font-semibold dark:text-white">{@plan.name}</span>
          </div>
          <div class="flex justify-between">
            <span class="text-gray-600 dark:text-gray-400">Price:</span>
            <span class="font-semibold dark:text-white">{@plan.price}</span>
          </div>
        </div>

        <%= if @payment_error && @payment_error_message do %>
          <div class="mb-4 p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
            <div class="flex items-start">
              <svg
                class="w-5 h-5 text-red-600 dark:text-red-400 mt-0.5 mr-3 flex-shrink-0"
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path
                  fill-rule="evenodd"
                  d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                  clip-rule="evenodd"
                />
              </svg>
              <p class="text-sm text-red-800 dark:text-red-200">
                {@payment_error_message}
              </p>
            </div>
          </div>
        <% end %>

        <div class="space-y-4">
          <!-- Google Pay Option -->
          <div id="google-pay-button-container" class="w-full"></div>

    <!-- Divider (only shows if Google Pay is available) -->
          <div class="relative hidden" id="payment-divider">
            <div class="absolute inset-0 flex items-center">
              <div class="w-full border-t border-gray-300 dark:border-gray-700"></div>
            </div>
            <div class="relative flex justify-center text-sm">
              <span class="px-2 bg-white dark:bg-gray-800 text-gray-500">Or pay with card</span>
            </div>
          </div>

    <!-- Card Payment Form or Error State -->
          <%= if @payment_error do %>
            <!-- Show retry button when there's an error -->
            <div class="text-center py-8">
              <p class="text-gray-600 dark:text-gray-400 mb-6">
                Please try again with a different payment method
              </p>
              <button
                phx-click="retry_payment"
                class="w-full py-3 px-4 rounded-lg font-semibold transition-colors bg-blue-500 hover:bg-blue-600 text-white"
              >
                Try Again
              </button>
            </div>
          <% else %>
            <!-- Show normal payment form -->
            <div
              id="card-element-normal"
              phx-hook="SquarePayment"
              data-app-id={@square_app_id}
              data-location-id={@square_location_id}
              data-plan-id={@plan.id}
              data-plan-name={@plan.name}
              data-plan-price={to_string(@plan.price_cents)}
            >
              <div
                class={[
                  "p-3 border rounded transition-colors mb-4",
                  "border-gray-300 dark:border-gray-700"
                ]}
              >
                <!-- Square Web Payments SDK card element will be mounted here -->
                <div class="text-gray-500 dark:text-gray-400 text-sm" id="loading-message">
                  Loading payment form...
                </div>
                <div id="card-container"></div>
              </div>

              <button
                id="payment-button"
                type="button"
                disabled={@processing}
                class={[
                  "w-full py-3 px-4 rounded-lg font-semibold transition-colors",
                  @processing && "bg-gray-300 text-gray-500 cursor-not-allowed",
                  !@processing && "bg-blue-500 hover:bg-blue-600 text-white"
                ]}
              >
                <%= if @processing do %>
                  <span class="flex items-center justify-center">
                    <svg
                      class="animate-spin -ml-1 mr-3 h-5 w-5 text-white"
                      fill="none"
                      viewBox="0 0 24 24"
                    >
                      <circle
                        class="opacity-25"
                        cx="12"
                        cy="12"
                        r="10"
                        stroke="currentColor"
                        stroke-width="4"
                      >
                      </circle>
                      <path
                        class="opacity-75"
                        fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                      >
                      </path>
                    </svg>
                    Processing...
                  </span>
                <% else %>
                  {if @plan.type == :one_time, do: "Purchase Now", else: "Subscribe Now"}
                <% end %>
              </button>

            <p class="text-xs text-gray-500 dark:text-gray-400 text-center">
            <%= if @plan.type == :one_time do %>
              Your payment will be processed securely through Square.
              This is a one-time purchase with no recurring charges.
            <% else %>
              Your subscription will be processed securely through Square.
              You can cancel anytime from your account settings.
            <% end %>
            </p>
            </div>
          <% end %>
        </div>
      </div>
    </div>
    """
  end

  defp subscription_status(assigns) do
    assigns = compute_subscription_display(assigns)

    ~H"""
    <div class="mt-6 p-4 bg-blue-50 dark:bg-gray-800 rounded-lg inline-block" data-subscription-id={assigns.subscription && assigns.subscription.id}>
      <div class="text-sm text-gray-600 dark:text-gray-400">
        <span class="font-semibold">Current Plan:</span>
        <span class="ml-2 text-gray-900 dark:text-white font-medium">
          {@plan_display_name}
        </span>
        <span :if={@subscription_status_label} class="mx-2">â€¢</span>
        <span :if={@subscription_status_label}>{@subscription_status_label}:</span>
        <span :if={@subscription_status_date} class="ml-2 text-gray-900 dark:text-white font-medium">
          {@subscription_status_date}
        </span>
        <span :if={@subscription_warning} class="text-amber-600 dark:text-amber-400">
          {@subscription_warning}
        </span>
      </div>
      <!-- Show pending subscription info if exists -->
      <div :if={@pending_subscription_info} class="mt-2 pt-2 border-t border-blue-200 dark:border-gray-700 text-sm text-blue-700 dark:text-blue-300">
        <span class="font-semibold">ðŸ“… Upcoming:</span>
        <span class="ml-2">{@pending_subscription_info}</span>
      </div>
    </div>
    """
  end

  # Compute display values for subscription status based on state
  defp compute_subscription_display(assigns) do
    assigns
    |> Map.put(:plan_display_name, format_plan_name(assigns.current_plan))
    |> compute_status_text()
    |> compute_pending_subscription_info()
  end

  # Pending subscription - show it separately as upcoming, not as current status
  defp compute_status_text(%{subscription: %{status: "PENDING"}} = assigns) do
    # Don't show pending as current status, it will be shown as "upcoming"
    # Show current active plan status instead (7-day pass or active subscription)
    assigns = Map.put(assigns, :subscription, nil)
    compute_status_text(assigns)
  end

  # Canceled subscription - show expiry date
  defp compute_status_text(
         %{subscription: %{status: "CANCELED", canceled_at: canceled_at}} = assigns
       )
       when not is_nil(canceled_at) do
    assigns
    |> Map.put(:subscription_status_label, "Expires")
    |> Map.put(:subscription_status_date, format_date(canceled_at))
    |> Map.put(:subscription_warning, nil)
  end

  # Active subscription - show renewal date
  defp compute_status_text(%{subscription: subscription} = assigns)
       when not is_nil(subscription) do
    assigns
    |> Map.put(:subscription_status_label, "Renews")
    |> Map.put(:subscription_status_date, format_renewal_date(subscription))
    |> Map.put(:subscription_warning, nil)
  end

  # No subscription but not on free plan - show warning
  defp compute_status_text(%{subscription: nil, current_plan: current_plan} = assigns) do
    if current_plan != :free do
      assigns
      |> Map.put(:subscription_status_label, nil)
      |> Map.put(:subscription_status_date, nil)
      |> Map.put(:subscription_warning, "No active subscription")
    else
      compute_status_text_default(assigns)
    end
  end

  # Free plan or normal state - no extra status
  defp compute_status_text(assigns) do
    compute_status_text_default(assigns)
  end

  defp compute_status_text_default(assigns) do
    assigns
    |> Map.put(:subscription_status_label, nil)
    |> Map.put(:subscription_status_date, nil)
    |> Map.put(:subscription_warning, nil)
  end

  # Compute pending subscription info to show as "upcoming"
  defp compute_pending_subscription_info(
         %{subscription: %{status: "PENDING", plan_id: plan_id, start_date: start_date}} = assigns
       ) do
    plan_name = format_plan_name(plan_id)
    date_str = format_date_string(start_date)
    Map.put(assigns, :pending_subscription_info, "#{plan_name} starts #{date_str}")
  end

  defp compute_pending_subscription_info(assigns) do
    Map.put(assigns, :pending_subscription_info, nil)
  end

  defp format_plan_name(:free), do: "Free"
  defp format_plan_name(:premium_monthly), do: "Premium Monthly"
  defp format_plan_name(:premium_yearly), do: "Premium Yearly"
  defp format_plan_name(:premium_weekly), do: "Premium Weekly"
  defp format_plan_name(:week_pass), do: "7-Day Pass"
  # Handle string versions too
  defp format_plan_name("premium_monthly"), do: "Premium Monthly"
  defp format_plan_name("premium_yearly"), do: "Premium Yearly"
  defp format_plan_name("premium_weekly"), do: "Premium Weekly"
  defp format_plan_name("premium_week_pass"), do: "7-Day Pass"
  defp format_plan_name("week_pass"), do: "7-Day Pass"
  defp format_plan_name(_), do: "Unknown"

  defp format_date(%DateTime{} = datetime) do
    Calendar.strftime(datetime, "%B %d, %Y")
  end

  defp format_date(nil), do: ""

  # Format date string (YYYY-MM-DD) to human readable format
  defp format_date_string(date_string) when is_binary(date_string) do
    case Date.from_iso8601(date_string) do
      {:ok, date} -> Calendar.strftime(date, "%B %d, %Y")
      _ -> date_string
    end
  end

  defp format_date_string(nil), do: ""

  defp format_renewal_date(subscription) do
    cond do
      subscription.next_billing_at ->
        format_date(subscription.next_billing_at)

      subscription.plan_id && String.contains?(subscription.plan_id, "monthly") ->
        # If no next billing date but it's monthly, estimate 30 days from start
        if subscription.started_at do
          next_date = DateTime.add(subscription.started_at, 30, :day)
          format_date(next_date)
        else
          "Monthly"
        end

      subscription.plan_id && String.contains?(subscription.plan_id, "yearly") ->
        # If no next billing date but it's yearly, estimate 365 days from start
        if subscription.started_at do
          next_date = DateTime.add(subscription.started_at, 365, :day)
          format_date(next_date)
        else
          "Yearly"
        end

      true ->
        "Unknown"
    end
  end

  # Check if a plan represents an active subscription
  defp has_active_subscription?(:premium_monthly), do: true
  defp has_active_subscription?(:premium_yearly), do: true
  defp has_active_subscription?(:premium_weekly), do: true
  defp has_active_subscription?(_), do: false
end
